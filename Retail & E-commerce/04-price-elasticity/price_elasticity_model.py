"""
Price Elasticity Analysis
Analyzes how price changes affect demand across product categories
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import r2_score, mean_squared_error\nimport joblib\nimport os\n\nclass PriceElasticityAnalyzer:\n    \"\"\"\n    Analyzes price elasticity of demand across product categories\n    \"\"\"\n    \n    def __init__(self):\n        self.elasticity_models = {}  # One model per category\n        self.scaler = StandardScaler()\n        self.feature_names = None\n        \n    def generate_elasticity_data(self, n_samples=500, random_state=42):\n        \"\"\"Generate synthetic price elasticity data\"\"\"\n        np.random.seed(random_state)\n        \n        categories = ['Electronics', 'Clothing', 'Food', 'Home & Garden', 'Sports']\n        data = []\n        \n        for category in categories:\n            # Category-specific elasticity\n            if category == 'Electronics':\n                base_elasticity = -1.5  # Elastic\n                price_range = (200, 1000)\n            elif category == 'Clothing':\n                base_elasticity = -1.2\n                price_range = (20, 150)\n            elif category == 'Food':\n                base_elasticity = -0.8  # Inelastic\n                price_range = (2, 20)\n            elif category == 'Home & Garden':\n                base_elasticity = -1.0\n                price_range = (30, 500)\n            else:  # Sports\n                base_elasticity = -1.3\n                price_range = (50, 300)\n            \n            for _ in range(n_samples // len(categories)):\n                price = np.random.uniform(price_range[0], price_range[1])\n                base_quantity = np.random.uniform(100, 1000)\n                \n                # Elasticity effect\n                quantity = base_quantity * (price / np.mean(price_range)) ** base_elasticity\n                quantity += np.random.normal(0, quantity * 0.1)  # Add noise\n                quantity = max(0, quantity)\n                \n                # Additional factors\n                competitor_price = price * np.random.uniform(0.8, 1.2)\n                marketing_spend = np.random.uniform(0, 5000)\n                seasonality = np.random.uniform(0.7, 1.3)\n                income_level = np.random.uniform(30000, 150000)\n                \n                data.append({\n                    'category': category,\n                    'price': price,\n                    'quantity_sold': quantity,\n                    'competitor_price': competitor_price,\n                    'marketing_spend': marketing_spend,\n                    'seasonality_factor': seasonality,\n                    'avg_income': income_level,\n                    'price_to_competitor': price / competitor_price,\n                    'log_price': np.log(price),\n                    'log_quantity': np.log(quantity + 1),\n                })\n        \n        return pd.DataFrame(data)\n    \n    def train(self, df, test_size=0.2, random_state=42):\n        \"\"\"Train elasticity models for each category\"\"\"\n        print(\"Training Price Elasticity Models...\")\n        \n        metrics_summary = {}\n        \n        for category in df['category'].unique():\n            print(f\"  - Training model for {category}...\")\n            \n            # Filter data for category\n            cat_data = df[df['category'] == category].copy()\n            \n            # Prepare features\n            X = cat_data[['price', 'competitor_price', 'marketing_spend', \n                          'seasonality_factor', 'avg_income', 'price_to_competitor']]\n            y = cat_data['quantity_sold']\n            \n            # Split data\n            X_train, X_test, y_train, y_test = train_test_split(\n                X, y, test_size=test_size, random_state=random_state\n            )\n            \n            # Scale features\n            scaler = StandardScaler()\n            X_train_scaled = scaler.fit_transform(X_train)\n            X_test_scaled = scaler.transform(X_test)\n            \n            # Train model\n            model = RandomForestRegressor(n_estimators=50, max_depth=5, random_state=random_state)\n            model.fit(X_train_scaled, y_train)\n            \n            # Evaluate\n            y_pred = model.predict(X_test_scaled)\n            r2 = r2_score(y_test, y_pred)\n            rmse = np.sqrt(mean_squared_error(y_test, y_pred))\n            \n            # Calculate price elasticity\n            # Using log-log regression for elasticity\n            X_log = cat_data[['log_price', 'competitor_price', 'marketing_spend', \n                             'seasonality_factor', 'avg_income']]\n            y_log = cat_data['log_quantity']\n            \n            X_train_log, X_test_log, y_train_log, y_test_log = train_test_split(\n                X_log, y_log, test_size=test_size, random_state=random_state\n            )\n            \n            elasticity_model = LinearRegression()\n            elasticity_model.fit(X_train_log, y_train_log)\n            price_elasticity = elasticity_model.coef_[0]  # Elasticity coefficient\n            \n            self.elasticity_models[category] = {\n                'model': model,\n                'scaler': scaler,\n                'elasticity_model': elasticity_model,\n                'price_elasticity': price_elasticity,\n                'r2': r2,\n                'rmse': rmse\n            }\n            \n            metrics_summary[category] = {\n                'elasticity': price_elasticity,\n                'r2': r2,\n                'rmse': rmse\n            }\n            \n            print(f\"    Elasticity: {price_elasticity:.3f}, R²: {r2:.4f}\")\n        \n        return metrics_summary\n    \n    def predict_quantity(self, category, price, competitor_price, marketing_spend, \n                        seasonality_factor, avg_income):\n        \"\"\"Predict quantity sold for given price and conditions\"\"\"\n        if category not in self.elasticity_models:\n            raise ValueError(f\"Category {category} not in trained models\")\n        \n        model_data = self.elasticity_models[category]\n        model = model_data['model']\n        scaler = model_data['scaler']\n        \n        # Prepare features\n        X = np.array([[\n            price, competitor_price, marketing_spend,\n            seasonality_factor, avg_income, price / competitor_price\n        ]])\n        \n        X_scaled = scaler.transform(X)\n        quantity = model.predict(X_scaled)[0]\n        \n        return max(0, quantity)\n    \n    def get_elasticity(self, category):\n        \"\"\"Get price elasticity coefficient for category\"\"\"\n        if category in self.elasticity_models:\n            return self.elasticity_models[category]['price_elasticity']\n        return None\n    \n    def simulate_price_change(self, category, base_price, price_changes, \n                             competitor_price, marketing_spend, seasonality_factor, avg_income):\n        \"\"\"Simulate demand at different price points\"\"\"\n        results = []\n        \n        for price_change in price_changes:\n            new_price = base_price * (1 + price_change)\n            quantity = self.predict_quantity(\n                category, new_price, competitor_price,\n                marketing_spend, seasonality_factor, avg_income\n            )\n            revenue = new_price * quantity\n            \n            results.append({\n                'price_change_%': price_change * 100,\n                'new_price': new_price,\n                'quantity': quantity,\n                'revenue': revenue\n            })\n        \n        return pd.DataFrame(results)\n    \n    def save_models(self, model_path='models'):\n        \"\"\"Save trained models\"\"\"\n        os.makedirs(model_path, exist_ok=True)\n        joblib.dump(self.elasticity_models, f'{model_path}/elasticity_models.pkl')\n        print(f\"✓ Models saved to {model_path}/\")\n    \n    def load_models(self, model_path='models'):\n        \"\"\"Load trained models\"\"\"\n        self.elasticity_models = joblib.load(f'{model_path}/elasticity_models.pkl')\n        print(f\"✓ Models loaded from {model_path}/\")\n\ndef main():\n    print(\"=\" * 60)\n    print(\"PRICE ELASTICITY ANALYSIS\")\n    print(\"=\" * 60)\n    \n    # Generate data\n    analyzer = PriceElasticityAnalyzer()\n    df = analyzer.generate_elasticity_data(n_samples=500)\n    \n    # Train models\n    print(\"\\n1. Training models...\")\n    metrics = analyzer.train(df)\n    \n    # Save models\n    print(\"\\n2. Saving models...\")\n    analyzer.save_models()\n    \n    # Display elasticity summary\n    print(\"\\n\" + \"=\" * 60)\n    print(\"PRICE ELASTICITY SUMMARY\")\n    print(\"=\" * 60)\n    \n    elasticity_summary = pd.DataFrame([\n        {\n            'Category': cat,\n            'Price_Elasticity': metrics[cat]['elasticity'],\n            'Elasticity_Type': 'Elastic' if metrics[cat]['elasticity'] < -1 else 'Inelastic',\n            'R2_Score': metrics[cat]['r2'],\n            'RMSE': metrics[cat]['rmse']\n        }\n        for cat in metrics\n    ])\n    \n    print(\"\\n\" + elasticity_summary.to_string(index=False))\n    print(\"\\n✓ Price Elasticity Analysis completed successfully!\")\n\nif __name__ == '__main__':\n    main()\n
