"""
Multi-Store SKU Forecasting
Forecasts sales for multiple items across multiple stores using time series
"""

import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from sklearn.preprocessing import StandardScaler\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error, r2_score, mean_absolute_percentage_error\nimport joblib\nimport os\n\nclass MultiStoreSKUForecaster:\n    \"\"\"\n    Forecasts sales for multiple SKUs across multiple stores\n    \"\"\"\n    \n    def __init__(self):\n        self.models = {}  # One model per store\n        self.scalers = {}  # One scaler per store\n        \n    def generate_multi_store_data(self, n_stores=10, n_skus=5, n_days=365, random_state=42):\n        \"\"\"Generate synthetic multi-store, multi-SKU sales data\"\"\"\n        np.random.seed(random_state)\n        \n        data = []\n        start_date = datetime(2023, 1, 1)\n        \n        for store_id in range(1, n_stores + 1):\n            # Store-specific parameters\n            store_size = np.random.choice(['small', 'medium', 'large'])\n            store_multiplier = {'small': 0.5, 'medium': 1.0, 'large': 1.5}[store_size]\n            \n            for sku_id in range(1, n_skus + 1):\n                # SKU-specific parameters\n                sku_category = np.random.choice(['Electronics', 'Clothing', 'Food', 'Home'])\n                base_sales = np.random.uniform(50, 200) * store_multiplier\n                \n                for day in range(n_days):\n                    date = start_date + timedelta(days=day)\n                    \n                    # Time features\n                    day_of_week = date.dayofweek\n                    month = date.month\n                    week_of_year = date.isocalendar()[1]\n                    quarter = (month - 1) // 3 + 1\n                    is_weekend = 1 if day_of_week >= 5 else 0\n                    \n                    # Demand components\n                    trend = 0.1 * day  # Slight upward trend\n                    seasonality = 50 * np.sin(2 * np.pi * day / 365)\n                    day_of_week_effect = 30 if is_weekend else -10\n                    promotional_effect = np.random.choice([0, 0, 0, 50], p=[0.8, 0.1, 0.05, 0.05])\n                    random_shock = np.random.normal(0, 20)\n                    \n                    # Sales calculation\n                    sales = (base_sales + trend + seasonality + day_of_week_effect + \n                            promotional_effect + random_shock)\n                    sales = max(0, sales)\n                    \n                    # Additional features\n                    price = np.random.uniform(10, 100)\n                    competitor_price = price * np.random.uniform(0.9, 1.1)\n                    inventory = np.random.uniform(100, 500)\n                    \n                    data.append({\n                        'date': date,\n                        'store_id': store_id,\n                        'store_size': store_size,\n                        'sku_id': sku_id,\n                        'sku_category': sku_category,\n                        'day_of_week': day_of_week,\n                        'month': month,\n                        'week_of_year': week_of_year,\n                        'quarter': quarter,\n                        'is_weekend': is_weekend,\n                        'day_of_month': date.day,\n                        'sales': sales,\n                        'price': price,\n                        'competitor_price': competitor_price,\n                        'inventory': inventory,\n                        'promotional_flag': 1 if promotional_effect > 0 else 0,\n                    })\n        \n        return pd.DataFrame(data)\n    \n    def train(self, df, test_size=0.2, random_state=42):\n        \"\"\"Train forecasting models for each store\"\"\"\n        print(\"Training Multi-Store SKU Forecasting Models...\")\n        \n        metrics_summary = {}\n        \n        for store_id in df['store_id'].unique():\n            print(f\"  - Training model for Store {store_id}...\")\n            \n            # Filter data for store\n            store_data = df[df['store_id'] == store_id].copy()\n            \n            # Encode categorical variables\n            store_data['store_size_encoded'] = pd.factorize(store_data['store_size'])[0]\n            store_data['sku_category_encoded'] = pd.factorize(store_data['sku_category'])[0]\n            \n            # Prepare features\n            feature_cols = ['sku_id', 'day_of_week', 'month', 'week_of_year', 'quarter',\n                          'is_weekend', 'day_of_month', 'price', 'competitor_price',\n                          'inventory', 'promotional_flag', 'store_size_encoded', 'sku_category_encoded']\n            \n            X = store_data[feature_cols]\n            y = store_data['sales']\n            \n            # Split data\n            X_train, X_test, y_train, y_test = train_test_split(\n                X, y, test_size=test_size, random_state=random_state\n            )\n            \n            # Scale features\n            scaler = StandardScaler()\n            X_train_scaled = scaler.fit_transform(X_train)\n            X_test_scaled = scaler.transform(X_test)\n            \n            # Train model\n            model = GradientBoostingRegressor(\n                n_estimators=100,\n                learning_rate=0.1,\n                max_depth=5,\n                random_state=random_state\n            )\n            model.fit(X_train_scaled, y_train)\n            \n            # Evaluate\n            y_pred = model.predict(X_test_scaled)\n            r2 = r2_score(y_test, y_pred)\n            rmse = np.sqrt(mean_squared_error(y_test, y_pred))\n            mape = mean_absolute_percentage_error(y_test, y_pred)\n            \n            self.models[store_id] = model\n            self.scalers[store_id] = scaler\n            \n            metrics_summary[store_id] = {\n                'r2': r2,\n                'rmse': rmse,\n                'mape': mape\n            }\n            \n            print(f\"    R²: {r2:.4f}, RMSE: {rmse:.2f}, MAPE: {mape:.4f}\")\n        \n        return metrics_summary\n    \n    def forecast(self, store_id, features_df):\n        \"\"\"Forecast sales for given store and features\"\"\"\n        if store_id not in self.models:\n            raise ValueError(f\"Store {store_id} not in trained models\")\n        \n        model = self.models[store_id]\n        scaler = self.scalers[store_id]\n        \n        # Prepare features\n        feature_cols = ['sku_id', 'day_of_week', 'month', 'week_of_year', 'quarter',\n                       'is_weekend', 'day_of_month', 'price', 'competitor_price',\n                       'inventory', 'promotional_flag', 'store_size_encoded', 'sku_category_encoded']\n        \n        X = features_df[feature_cols]\n        X_scaled = scaler.transform(X)\n        \n        forecast = model.predict(X_scaled)\n        return forecast\n    \n    def save_models(self, model_path='models'):\n        \"\"\"Save trained models\"\"\"\n        os.makedirs(model_path, exist_ok=True)\n        joblib.dump(self.models, f'{model_path}/store_models.pkl')\n        joblib.dump(self.scalers, f'{model_path}/store_scalers.pkl')\n        print(f\"✓ Models saved to {model_path}/\")\n    \n    def load_models(self, model_path='models'):\n        \"\"\"Load trained models\"\"\"\n        self.models = joblib.load(f'{model_path}/store_models.pkl')\n        self.scalers = joblib.load(f'{model_path}/store_scalers.pkl')\n        print(f\"✓ Models loaded from {model_path}/\")\n\ndef main():\n    print(\"=\" * 60)\n    print(\"MULTI-STORE SKU FORECASTING\")\n    print(\"=\" * 60)\n    \n    # Generate data\n    print(\"\\n1. Generating data...\")\n    forecaster = MultiStoreSKUForecaster()\n    df = forecaster.generate_multi_store_data(n_stores=10, n_skus=5, n_days=365)\n    print(f\"   ✓ Generated {len(df)} records\")\n    \n    # Train models\n    print(\"\\n2. Training models...\")\n    metrics = forecaster.train(df, test_size=0.2, random_state=42)\n    \n    # Save models\n    print(\"\\n3. Saving models...\")\n    forecaster.save_models()\n    \n    # Display results\n    print(\"\\n\" + \"=\" * 60)\n    print(\"MODEL PERFORMANCE SUMMARY\")\n    print(\"=\" * 60)\n    \n    summary_df = pd.DataFrame([\n        {\n            'Store_ID': store_id,\n            'R2_Score': f\"{metrics[store_id]['r2']:.4f}\",\n            'RMSE': f\"{metrics[store_id]['rmse']:.2f}\",\n            'MAPE': f\"{metrics[store_id]['mape']:.4f}\"\n        }\n        for store_id in sorted(metrics.keys())\n    ])\n    \n    print(\"\\n\" + summary_df.to_string(index=False))\n    print(\"\\n✓ Multi-Store SKU Forecasting training completed successfully!\")\n\nif __name__ == '__main__':\n    main()\n
