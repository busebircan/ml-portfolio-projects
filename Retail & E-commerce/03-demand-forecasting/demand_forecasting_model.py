"""
Demand Forecasting with Inventory Optimization Model
Predicts demand and optimizes reorder points and safety stock
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import StandardScaler\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error, mean_absolute_percentage_error\nimport joblib\nimport os\n\nclass DemandForecaster:\n    \"\"\"\n    Forecasts demand and optimizes inventory parameters\n    \"\"\"\n    \n    def __init__(self):\n        self.demand_model = None\n        self.scaler = StandardScaler()\n        self.feature_names = None\n        \n    def preprocess_data(self, df, fit=True):\n        \"\"\"Preprocess data for modeling\"\"\"\n        df = df.copy()\n        \n        # Drop date and product_id\n        if 'date' in df.columns:\n            df = df.drop('date', axis=1)\n        if 'product_id' in df.columns:\n            df = df.drop('product_id', axis=1)\n        \n        # Store feature names\n        if fit:\n            self.feature_names = df.columns.tolist()\n            # Remove target variables\n            for col in ['demand', 'base_demand', 'trend_component', 'seasonal_component']:\n                if col in self.feature_names:\n                    self.feature_names.remove(col)\n        \n        return df\n    \n    def train(self, df, test_size=0.2, random_state=42):\n        \"\"\"Train the demand forecasting model\"\"\"\n        print(\"Training Demand Forecasting Model...\")\n        \n        # Preprocess data\n        df_processed = self.preprocess_data(df, fit=True)\n        \n        # Prepare features and target\n        X = df_processed.drop(['demand', 'base_demand', 'trend_component', 'seasonal_component'], axis=1)\n        y = df_processed['demand']\n        \n        # Split data\n        X_train, X_test, y_train, y_test = train_test_split(\n            X, y, test_size=test_size, random_state=random_state\n        )\n        \n        # Scale features\n        X_train_scaled = self.scaler.fit_transform(X_train)\n        X_test_scaled = self.scaler.transform(X_test)\n        \n        # Train model\n        print(\"  - Training Gradient Boosting Regressor...\")\n        self.demand_model = GradientBoostingRegressor(\n            n_estimators=100,\n            learning_rate=0.1,\n            max_depth=5,\n            random_state=random_state\n        )\n        self.demand_model.fit(X_train_scaled, y_train)\n        \n        # Evaluate model\n        y_pred = self.demand_model.predict(X_test_scaled)\n        \n        metrics = {\n            'rmse': np.sqrt(mean_squared_error(y_test, y_pred)),\n            'mae': mean_absolute_error(y_test, y_pred),\n            'mape': mean_absolute_percentage_error(y_test, y_pred),\n            'r2': r2_score(y_test, y_pred)\n        }\n        \n        print(f\"    RMSE: {metrics['rmse']:.2f}\")\n        print(f\"    MAE: {metrics['mae']:.2f}\")\n        print(f\"    MAPE: {metrics['mape']:.4f}\")\n        print(f\"    R²: {metrics['r2']:.4f}\")\n        \n        return metrics\n    \n    def forecast_demand(self, features_df):\n        \"\"\"Forecast demand for given features\"\"\"\n        features_processed = self.preprocess_data(features_df, fit=False)\n        X = features_processed.drop(['demand', 'base_demand', 'trend_component', 'seasonal_component'], \n                                   axis=1, errors='ignore')\n        X_scaled = self.scaler.transform(X)\n        \n        forecast = self.demand_model.predict(X_scaled)\n        return forecast\n    \n    def optimize_inventory(self, features_df):\n        \"\"\"\n        Optimize inventory parameters based on forecasted demand\n        Returns optimized reorder points and safety stock\n        \"\"\"\n        # Forecast demand\n        forecasted_demand = self.forecast_demand(features_df)\n        \n        # Extract inventory parameters\n        lead_times = features_df['lead_time_days'].values\n        holding_costs = features_df['holding_cost_per_unit'].values\n        stockout_costs = features_df['stockout_cost_per_unit'].values\n        order_costs = features_df['order_cost'].values\n        demand_stds = features_df['demand_std'].values\n        \n        # Calculate optimized parameters\n        # Service level (95%)\n        z_score = 1.65\n        \n        safety_stocks = z_score * demand_stds * np.sqrt(lead_times)\n        reorder_points = forecasted_demand * lead_times + safety_stocks\n        \n        # Economic Order Quantity\n        annual_demands = forecasted_demand * 365\n        eoqs = np.sqrt(2 * annual_demands * order_costs / holding_costs)\n        \n        # Total inventory cost\n        holding_costs_total = (eoqs / 2 + safety_stocks) * holding_costs\n        ordering_costs_total = (annual_demands / eoqs) * order_costs\n        total_costs = holding_costs_total + ordering_costs_total\n        \n        return {\n            'forecasted_demand': forecasted_demand,\n            'safety_stock': safety_stocks,\n            'reorder_point': reorder_points,\n            'eoq': eoqs,\n            'holding_cost': holding_costs_total,\n            'ordering_cost': ordering_costs_total,\n            'total_inventory_cost': total_costs\n        }\n    \n    def save_model(self, model_path='models'):\n        \"\"\"Save trained model\"\"\"\n        os.makedirs(model_path, exist_ok=True)\n        joblib.dump(self.demand_model, f'{model_path}/demand_model.pkl')\n        joblib.dump(self.scaler, f'{model_path}/scaler.pkl')\n        print(f\"✓ Model saved to {model_path}/\")\n    \n    def load_model(self, model_path='models'):\n        \"\"\"Load trained model\"\"\"\n        self.demand_model = joblib.load(f'{model_path}/demand_model.pkl')\n        self.scaler = joblib.load(f'{model_path}/scaler.pkl')\n        print(f\"✓ Model loaded from {model_path}/\")\n\ndef main():\n    \"\"\"Main execution\"\"\"\n    from generate_data import generate_demand_forecasting_data\n    \n    print(\"=\" * 60)\n    print(\"DEMAND FORECASTING WITH INVENTORY OPTIMIZATION\")\n    print(\"=\" * 60)\n    \n    # Generate data\n    df = generate_demand_forecasting_data(n_days=365, n_products=5)\n    \n    # Initialize and train model\n    forecaster = DemandForecaster()\n    metrics = forecaster.train(df)\n    \n    # Save model\n    forecaster.save_model()\n    \n    # Test optimization\n    print(\"\\n\" + \"=\" * 60)\n    print(\"INVENTORY OPTIMIZATION RESULTS\")\n    print(\"=\" * 60)\n    \n    test_df = df.head(10).copy()\n    optimization = forecaster.optimize_inventory(test_df)\n    \n    results = pd.DataFrame({\n        'Forecasted_Demand': optimization['forecasted_demand'],\n        'Safety_Stock': optimization['safety_stock'],\n        'Reorder_Point': optimization['reorder_point'],\n        'EOQ': optimization['eoq'],\n        'Total_Inventory_Cost': optimization['total_inventory_cost']\n    })\n    \n    print(\"\\nSample Optimization Results:\")\n    print(results.to_string(index=False))\n    \n    print(\"\\n✓ Demand Forecasting Model training completed successfully!\")\n\nif __name__ == '__main__':\n    main()\n
